/*
** Copyright (C) 2023 Victron Energy B.V.
** See LICENSE.txt for license information.
*/

#include "themeparser.h"

#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QRegularExpression>
#include <QVariant>
#include <QColor>
#include <QMetaEnum>

namespace {
	QRegularExpression optimizeExpression(const QString &expression)
	{
		QRegularExpression regexp(expression);
		regexp.optimize();
		return regexp;
	}
}

namespace Victron {
namespace VenusOS {

static const QString FilePreamble =
R"(
/*
** Copyright (C) 2023 Victron Energy B.V.
** See LICENSE.txt for license information.
*/

// THIS FILE IS AUTOMATICALLY GENERATED!
// DO NOT EDIT IT MANUALLY!
// YOU NEED TO RUN themeparser IF ANY OF
// THE THEME .json FILES CHANGE!

// TO CONVERT TO FLAT MODE, RUN THE FOLLOWING 12x ON EVERY QML+JS FILE:
// sed -E 's/Theme\.([0-9a-zA-Z.]+)\.([0-9a-zA-Z]+)/Theme.\1_\2/'
// TO CONVERT TO NESTED MODE, RUN THE FOLLOWING 12x ON EVERY QML+JS FILE:
// sed -E 's/Theme\.([0-9a-zA-Z]+)[_]([0-9a-zA-Z.]+)/Theme.\1.\2/'
//
// e.g. where theme_flat.sh is:
//   for i in \`seq 1 12\`
//   do
//       sed -E 's/Theme\.([0-9a-zA-Z.]+)\.([0-9a-zA-Z]+)/Theme.\1_\2/' -i $1
//   done
// simply invoke:
//   find . -name "*qml" -o -name "*js" | xargs -L1 theme_flat.sh
//
// e.g. where theme_nested.sh is:
//   for i in \`seq 1 12\`
//   do
//       sed -E 's/Theme\.([0-9a-zA-Z]+)[_]([0-9a-zA-Z.]+)/Theme.\1.\2/' -i $1
//   done
// simply invoke:
//   find . -name "*qml" -o -name "*js" | xargs -L1 theme_nested.sh

#ifndef VICTRON_VENUSOS_GUI_V2_THEMEOBJECTS_H
#define VICTRON_VENUSOS_GUI_V2_THEMEOBJECTS_H

#include <QObject>
#include <QColor>
#include <QFont>
#include <QVariant>
#include <QVariantMap>

#include "theme.h"

namespace Victron {
namespace VenusOS {

)";

// %1 is typename, %2 is property name
static const QString FlatThemeNonVaryingPropertyDeclaration =
R"(	Q_PROPERTY(%1 %2 READ %2 CONSTANT FINAL))";

// %1 is typename, %2 is property name
static const QString FlatThemeSizeVaryingPropertyDeclaration =
R"(	Q_PROPERTY(%1 %2 READ %2 NOTIFY screenSizeChanged_parameterless FINAL))";

// %1 is typename, %2 is property name
static const QString FlatThemeColorVaryingPropertyDeclaration =
R"(	Q_PROPERTY(%1 %2 READ %2 NOTIFY colorSchemeChanged_parameterless FINAL))";

// %1 is type, %2 is name, %3 is chained-ternary-value.
// e.g. m_themeValue == Theme::FiveInch ? 1024 : 800
static const QString FlatThemePropertyAccessor =
R"(	%1 %2() const {
		return %3;
	}
)";

static const QString ThemeClassTemplates =
R"(
class Internal_Theme_NonVaryingClass : public QObject
{
	Q_OBJECT
	QML_ELEMENT

public:
	Internal_Theme_NonVaryingClass(QObject *parent = nullptr)
		: QObject(parent) {}

Q_SIGNALS:
	void propertiesChanged(); // never emitted or connected for NonVarying.
};

class Internal_Theme_SizeVaryingClass : public QObject
{
	Q_OBJECT
	QML_ELEMENT

public:
	Internal_Theme_SizeVaryingClass(QObject *parent = nullptr)
		: QObject(parent) {}

Q_SIGNALS:
	void propertiesChanged(); // used as QML change signal by leaf classes.
	void themeValueChanged(Theme::ScreenSize newValue);

public Q_SLOTS:
	void handleThemeValueChanged(Theme::ScreenSize newValue) {
		if (m_themeValue != newValue) {
			m_themeValue = newValue;
			Q_EMIT themeValueChanged(newValue);
			Q_EMIT propertiesChanged();
		}
	}

protected:
	Theme::ScreenSize m_themeValue = Theme::FiveInch;
};

class Internal_Theme_ColorVaryingClass : public QObject
{
	Q_OBJECT
	QML_ELEMENT

public:
	Internal_Theme_ColorVaryingClass(QObject *parent = nullptr)
		: QObject(parent) {}

Q_SIGNALS:
	void propertiesChanged(); // used as QML change signal by leaf classes.
	void themeValueChanged(Theme::ColorScheme newValue);

public Q_SLOTS:
	void handleThemeValueChanged(Theme::ColorScheme newValue) {
		if (m_themeValue != newValue) {
			m_themeValue = newValue;
			Q_EMIT themeValueChanged(newValue);
			Q_EMIT propertiesChanged();
		}
	}

protected:
	Theme::ColorScheme m_themeValue = Theme::Dark;
};
)";

// %1 is type, %2 is name
static const QString LeafThemeClassPropertyDeclaration =
R"(	Q_PROPERTY(%1 %2 READ %2 NOTIFY propertiesChanged FINAL))";

// %1 is type, %2 is name, %3 is chained-ternary-value.
// e.g. m_themeValue == Theme::FiveInch ? 1024 : 800
static const QString LeafThemeClassPropertyAccessor =
R"(	%1 %2() const {
		return %3;
	}
)";

// %1 is the class name, %2 is the type to extend (SizeVaryingClass, ColorVaryingClass, NonVaryingClass)
static const QString LeafThemeClassDeclaration =
R"(
class Internal_Theme_%1
	: public Internal_Theme_%2
{
	Q_OBJECT
	QML_ELEMENT

	// leaf property declarations
%3

public:
	Internal_Theme_%1(QObject *parent = nullptr)
		: Internal_Theme_%2(parent) {}

	// leaf property accessors
%4
};
)";

// %1 is the private subobject class name, %2 is the private subobject name.
static const QString ThemeClassPropertyDeclaration =
R"(	Q_PROPERTY(Internal_Theme_%1* %2 READ %2 CONSTANT FINAL))";

// %1 is the class name, %2 is the private subobject name, %3 is the private subobject class name
static const QString ThemeClassSignalConnection =
R"(		connect(this, &Internal_Theme_%1::themeValueChanged,
			&m_%2, &Internal_Theme_%3::handleThemeValueChanged);)";

// %1 is the private subobject class name, %2 is the private subobject name
static const QString ThemeClassPropertyAccessor =
R"(	const Internal_Theme_%1 *%2() const { return &m_%2; })";

// %1 is the private subobject class name, %2 is the private subobject name
static const QString ThemeClassPrivateSubObject =
R"(	Internal_Theme_%1 m_%2;)";

// %1 is the class name, %2 is the type to extend (SizeVaryingClass, ColorVaryingClass, NonVaryingClass)
static const QString ThemeClassDeclaration =
R"(
class Internal_Theme_%1
	: public Internal_Theme_%2
{
	Q_OBJECT
	QML_ELEMENT

	// property declarations
%3

public:
	Internal_Theme_%1(QObject *parent = nullptr)
		: Internal_Theme_%2(parent)
	{
		// signal connections
%4
	}

	// property accessors
%5

private:
	// sub-objects
%6
};
)";

static const QString ThemeObjectSizeChangedSignalConnection =
R"(		connect(this, &Theme::screenSizeChanged,
			&m_%1, &Internal_Theme_%2::handleThemeValueChanged);)";

static const QString ThemeObjectColorChangedSignalConnection =
R"(		connect(this, &Theme::colorSchemeChanged,
			&m_%1, &Internal_Theme_%2::handleThemeValueChanged);)";

static const QString ThemeObjectStatusColorValueImplementation =
R"(	Q_INVOKABLE QColor statusColorValue(StatusLevel level, bool darkColor = false) const
	{
		const QVariant c = (level == Ok && darkColor) ? m_color.darkOk()
			: (level == Ok) ? m_color.ok()
			: (level == Warning && darkColor) ? m_color.darkWarning()
			: (level == Warning) ? m_color.warning()
			: (level == Critical && darkColor) ? m_color.darkCritical()
			: m_color.critical();
		return c.typeId() == QMetaType::QColor ? c.value<QColor>() : QColor(c.value<QString>());
	}
)";

static const QString FlatThemeObjectStatusColorValueImplementation =
R"(	Q_INVOKABLE QColor statusColorValue(StatusLevel level, bool darkColor = false) const
	{
		const QVariant c = (level == Ok && darkColor) ? color_darkOk()
			: (level == Ok) ? color_ok()
			: (level == Warning && darkColor) ? color_darkWarning()
			: (level == Warning) ? color_warning()
			: (level == Critical && darkColor) ? color_darkCritical()
			: color_critical();
		return c.typeId() == QMetaType::QColor ? c.value<QColor>() : QColor(c.value<QString>());
	}
)";

static const QString ThemeObjectDeclaration =
R"(
class ThemeSingleton : public Theme
{
	Q_OBJECT
	QML_NAMED_ELEMENT(Theme)
	QML_SINGLETON

	// property declarations
%1

public:
	ThemeSingleton(QObject *parent = nullptr)
		: Theme(parent)
	{
		// size/color changed signal connections
%2
	}

	// property accessors
%3

	// statusColorValue method implementation
%4

private:
	// sub-objects
%5
};
)";


static const QString FilePostfix =
R"(

} // namespace VenusOS
} // namespace Victron

#endif // VICTRON_VENUSOS_GUI_V2_THEMEOBJECTS_H

)";

namespace {

struct LeafClassProperty {
	QString declaration;
	QString accessor;
};

// This function generates a property declaration + accessor
// for a property value with multiple variations.
// Example: geometry.screen.width property value varies
// depending on the screen size (7 inch vs 5 inch).
// In this case, the property accessor consists of
// a ternary statement which returns the appropriate value.
LeafClassProperty generateLeafClassProperty(
		const QVector<ThemeInfo> &values,
		const QVariant &firstValue,
		const QString &key,
		const QString subtreeKey)
{
	QString chainedTernaryValues;
	for (int i = 0; i < values.size(); ++i) {
		const ThemeInfo &info(values[i]);
		if (!info.subtrees.contains(subtreeKey)) {
			qWarning() << "Missing subtree:" << subtreeKey << "for variant:" << info.ternaryCondition;
			qFatal("Fix the .json files!");
			continue; // avoid random crash in release mode.
		}
		if (!info.subtrees[subtreeKey]->contains(key)) {
			qWarning() << "Missing value" << key << "in subtree:" << subtreeKey << "for variant:" << info.ternaryCondition;
			qFatal("Fix the .json files!");
			continue; // avoid random crash in release mode.
		}
		const QVariant &value(info.subtrees[subtreeKey]->value(key));
		const QVariant colorVariant = QVariant::fromValue<QColor>(QColor(127, 127, 127, 127));
		const QString valueAsString = (value.typeId() == colorVariant.typeId())
			? QStringLiteral("QColor(%1, %2, %3, %4)").arg(
				QString::number(value.value<QColor>().red()),
				QString::number(value.value<QColor>().green()),
				QString::number(value.value<QColor>().blue()),
				QString::number(value.value<QColor>().alpha()))
			: value.toString();
		if (i < (values.size() - 1)) {
			chainedTernaryValues.append(QStringLiteral("%1 %2\n\t\t\t: ").arg(
				info.ternaryCondition,
				valueAsString));
		} else {
			chainedTernaryValues.append(valueAsString);
		}
	}

	const QString typeName = QString(QMetaType(firstValue.typeId()).name());
	LeafClassProperty ret;
	ret.accessor =
		LeafThemeClassPropertyAccessor.arg(
			typeName == QStringLiteral("double") ? QStringLiteral("qreal") : typeName,
			key,
			chainedTernaryValues);
	ret.declaration =
		LeafThemeClassPropertyDeclaration.arg(
			typeName == QStringLiteral("double") ? QStringLiteral("qreal") : typeName,
			key);
	return ret;
}

// This function generates a property declaration + accessor
// for a property value with multiple variations.
// Example: geometry.screen.width property value varies
// depending on the screen size (7 inch vs 5 inch).
// In this case, the property accessor consists of
// a ternary statement which returns the appropriate value.
LeafClassProperty generateFlatThemeObjectProperty(
	const QVector<ThemeInfo> &values,
	const QString &key)
{
	QString chainedTernaryValues;
	for (int i = 0; i < values.size(); ++i) {
		const ThemeInfo &info(values[i]);
		const QVariant &value(info.values.value(key));
		const QVariant colorVariant = QVariant::fromValue<QColor>(QColor(127, 127, 127, 127));
		const QString valueAsString = (value.typeId() == colorVariant.typeId())
			? QStringLiteral("QColor(%1, %2, %3, %4)").arg(
				QString::number(value.value<QColor>().red()),
				QString::number(value.value<QColor>().green()),
				QString::number(value.value<QColor>().blue()),
				QString::number(value.value<QColor>().alpha()))
			: value.toString();
		if (i < (values.size() - 1)) {
			chainedTernaryValues.append(QStringLiteral("%1 %2\n\t\t\t: ").arg(
				info.ternaryCondition,
				valueAsString));
		} else {
			chainedTernaryValues.append(valueAsString);
		}
	}

	const ThemeInfo firstInfo = values.first();
	const QVariant firstValue = firstInfo.values.value(key);
	const QString typeName = QString(QMetaType(firstValue.typeId()).name());
	LeafClassProperty ret;
	ret.accessor =
		FlatThemePropertyAccessor.arg(
			typeName == QStringLiteral("double") ? QStringLiteral("qreal") : typeName,
			key,
			chainedTernaryValues);
	ret.declaration =
		(firstInfo.variesByScreenSize ? FlatThemeSizeVaryingPropertyDeclaration
		: firstInfo.variesByColorScheme ? FlatThemeColorVaryingPropertyDeclaration
		: FlatThemeNonVaryingPropertyDeclaration).arg(
			typeName == QStringLiteral("double") ? QStringLiteral("qreal") : typeName,
			key);
	return ret;
}

}; // anonymous namespace

ThemeParser::ThemeParser(QObject *parent)
	: QObject(parent)
{
}

ThemeParser::~ThemeParser()
{
}

QString ThemeParser::generateLeafClassCode(
		const QVector<ThemeInfo> &values,
		QVariantMap *tree,
		const QString &namePrefix)
{
	if (m_generatedClassNames.contains(namePrefix)) {
		qWarning() << "Have already generated leaf class:" << namePrefix;
		return QString();
	} else {
		m_generatedClassNames.insert(namePrefix);
	}

	QStringList propertyDeclarations;
	QStringList propertyAccessors;

	const QStringList keys = tree->keys();
	for (const QString &key : keys) {
		// this an "immediate value" property.
		const QVariant &value = tree->value(key);
		LeafClassProperty prop = generateLeafClassProperty(values, value, key, values.first().subtrees.key(tree));
		propertyAccessors.append(prop.accessor);
		propertyDeclarations.append(prop.declaration);
	}

	QString classCode = LeafThemeClassDeclaration.arg(
		namePrefix,
		values.first().variesByColorScheme ? QStringLiteral("ColorVaryingClass")
			: values.first().variesByScreenSize ? QStringLiteral("SizeVaryingClass")
			: QStringLiteral("NonVaryingClass"),
		propertyDeclarations.join('\n'),
		propertyAccessors.join ('\n'));
	return classCode.toUtf8();
}

QString ThemeParser::generateThemeClassCode(
		const QVector<ThemeInfo> &values,
		QVariantMap *tree,
		const QString &namePrefix)
{
	bool hasSubtree = false;
	for (const QString &key : tree->keys()) {
		const QVariant value = tree->value(key);
		if (value.typeId() == qMetaTypeId<QVariantMap*>()) {
			hasSubtree = true;
			break;
		}
	}

	if (!hasSubtree) {
		// this tree is actually a leaf, with only immediate-value properties.
		return generateLeafClassCode(values, tree, namePrefix);
	}

	if (m_generatedClassNames.contains(namePrefix)) {
		qWarning() << "Have already generated class:" << namePrefix;
		return QString();
	} else {
		m_generatedClassNames.insert(namePrefix);
	}

	// this tree has subtrees as well as (possibly) immediate-value properties.
	QStringList generatedClasses;
	QStringList generatedThemeClassSubObjects;
	QStringList generatedThemeClassPropertyAccessors;
	QStringList generatedThemeClassSignalConnections;
	QStringList generatedThemeClassPropertyDeclarations;

	for (const QString &key : tree->keys()) {
		const QVariant value = tree->value(key);
		if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
			// this an "immediate value" property.
			LeafClassProperty prop = generateLeafClassProperty(values, value, key, values.first().subtrees.key(tree));
			generatedThemeClassPropertyAccessors.append(prop.accessor);
			generatedThemeClassPropertyDeclarations.append(prop.declaration);
		} else {
			// this is a sub-object property.
			QVariantMap *subtree = value.value<QVariantMap*>();
			const QString subNamePrefix = QStringLiteral("%1_%2").arg(namePrefix, key);
			generatedClasses.append(generateThemeClassCode(values, subtree, subNamePrefix));
			generatedThemeClassSubObjects.append(ThemeClassPrivateSubObject.arg(subNamePrefix, key));
			generatedThemeClassPropertyAccessors.append(ThemeClassPropertyAccessor.arg(subNamePrefix, key));
			if (values.first().variesByScreenSize || values.first().variesByColorScheme) {
				generatedThemeClassSignalConnections.append(ThemeClassSignalConnection.arg(namePrefix, key, subNamePrefix));
			}
			generatedThemeClassPropertyDeclarations.append(ThemeClassPropertyDeclaration.arg(subNamePrefix, key));
		}
	}

	QString ret;
	ret.append(generatedClasses.join('\n'));
	ret.append(ThemeClassDeclaration.arg(
		namePrefix,
		values.first().variesByScreenSize ? QStringLiteral("SizeVaryingClass")
			: values.first().variesByColorScheme ? QStringLiteral("ColorVaryingClass")
			: QStringLiteral("NonVaryingClass"),
		generatedThemeClassPropertyDeclarations.join('\n'),
		generatedThemeClassSignalConnections.join('\n'),
		generatedThemeClassPropertyAccessors.join('\n'),
		generatedThemeClassSubObjects.join('\n')));
	return ret;
}

bool ThemeParser::generateThemeCode(
		const QString &themeDir,
		const QString &outputFile,
		bool generateFlatThemeObject)
{
	if (!load(themeDir, generateFlatThemeObject)) {
		qWarning() << "Failed to load theme files.";
		return false;
	}

	QStringList generatedClasses;
	QStringList generatedThemeObjectSubObjects;
	QStringList generatedThemeObjectPropertyAccessors;
	QStringList generatedThemeObjectSignalConnections;
	QStringList generatedThemeObjectPropertyDeclarations;

	if (generateFlatThemeObject) {
		// generate a single flat theme object with all properties.
		const QVariantMap &svalues = m_sizeVaryingThemeValues.first().values;
		for (const QString &key : svalues.keys()) {
			LeafClassProperty prop = generateFlatThemeObjectProperty(m_sizeVaryingThemeValues, key);
			generatedThemeObjectPropertyAccessors.append(prop.accessor);
			generatedThemeObjectPropertyDeclarations.append(prop.declaration);
		}

		const QVariantMap &cvalues = m_colorVaryingThemeValues.first().values;
		for (const QString &key : cvalues.keys()) {
			LeafClassProperty prop = generateFlatThemeObjectProperty(m_colorVaryingThemeValues, key);
			generatedThemeObjectPropertyAccessors.append(prop.accessor);
			generatedThemeObjectPropertyDeclarations.append(prop.declaration);
		}

		const QVariantMap &nvalues = m_nonVaryingThemeValues.first().values;
		for (const QString &key : nvalues.keys()) {
			LeafClassProperty prop = generateFlatThemeObjectProperty(m_nonVaryingThemeValues, key);
			generatedThemeObjectPropertyAccessors.append(prop.accessor);
			generatedThemeObjectPropertyDeclarations.append(prop.declaration);
		}
	} else {
		// generate a hierarchy of subobjects with properties.

		const QVariantMap &svalues = m_sizeVaryingThemeValues.first().values;
		for (const QString &key : svalues.keys()) {
			const QVariant value = svalues.value(key);
			if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
				// Should instead be a sub-object property.
				qWarning() << "Immediate value property of Theme object not allowed!  Key = " << key << " = " << value;
			} else {
				QVariantMap *subtree = value.value<QVariantMap*>();
				generatedClasses.append(generateThemeClassCode(m_sizeVaryingThemeValues, subtree, key));
				generatedThemeObjectSubObjects.append(ThemeClassPrivateSubObject.arg(key, key));
				generatedThemeObjectPropertyAccessors.append(ThemeClassPropertyAccessor.arg(key, key));
				generatedThemeObjectSignalConnections.append(ThemeObjectSizeChangedSignalConnection.arg(key, key));
				generatedThemeObjectPropertyDeclarations.append(ThemeClassPropertyDeclaration.arg(key, key));
			}
		}

		const QVariantMap &cvalues = m_colorVaryingThemeValues.first().values;
		for (const QString &key : cvalues.keys()) {
			const QVariant value = cvalues.value(key);
			if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
				// Should instead be a sub-object property.
				qWarning() << "Immediate value property of Theme object not allowed!  Key = " << key << " = " << value;
			} else {
				QVariantMap *subtree = value.value<QVariantMap*>();
				generatedClasses.append(generateThemeClassCode(m_colorVaryingThemeValues, subtree, key));
				generatedThemeObjectSubObjects.append(ThemeClassPrivateSubObject.arg(key, key));
				generatedThemeObjectPropertyAccessors.append(ThemeClassPropertyAccessor.arg(key, key));
				generatedThemeObjectSignalConnections.append(ThemeObjectColorChangedSignalConnection.arg(key, key));
				generatedThemeObjectPropertyDeclarations.append(ThemeClassPropertyDeclaration.arg(key, key));
			}
		}

		const QVariantMap &nvalues = m_nonVaryingThemeValues.first().values;
		for (const QString &key : nvalues.keys()) {
			const QVariant value = nvalues.value(key);
			if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
				// Should instead be a sub-object property.
				qWarning() << "Immediate value property of Theme object not allowed!  Key = " << key << " = " << value;
			} else {
				QVariantMap *subtree = value.value<QVariantMap*>();
				generatedClasses.append(generateThemeClassCode(m_nonVaryingThemeValues, subtree, key));
				generatedThemeObjectSubObjects.append(ThemeClassPrivateSubObject.arg(key, key));
				generatedThemeObjectPropertyAccessors.append(ThemeClassPropertyAccessor.arg(key, key));
				generatedThemeObjectPropertyDeclarations.append(ThemeClassPropertyDeclaration.arg(key, key));
			}
		}
	}

	QByteArray fileData;
	fileData.append(FilePreamble.toUtf8());

	if (!generateFlatThemeObject) {
		fileData.append(ThemeClassTemplates.toUtf8());
		fileData.append(generatedClasses.join('\n').toUtf8());
	}

	fileData.append(ThemeObjectDeclaration.arg(
		generatedThemeObjectPropertyDeclarations.join('\n'),
		generatedThemeObjectSignalConnections.join('\n'),
		generatedThemeObjectPropertyAccessors.join('\n'),
		generateFlatThemeObject
			? FlatThemeObjectStatusColorValueImplementation
			: ThemeObjectStatusColorValueImplementation,
		generatedThemeObjectSubObjects.join('\n')).toUtf8());

	fileData.append(FilePostfix.toUtf8());

	QFile writeFile(outputFile);
	if (writeFile.open(QIODevice::WriteOnly)) {
		writeFile.write(fileData);
		writeFile.close();
		return true;
	} else {
		qWarning() << "Unable to open themeobjects.h for writing";
		return false;
	}
}

bool ThemeParser::load(const QString &themeDir, bool generateFlatThemeObject)
{
	bool ret = true;

	auto screenSizeMetaEnum = QMetaEnum::fromType<ThemeParser::ScreenSize>();
	for (int idx = 0; idx < screenSizeMetaEnum.keyCount(); ++idx) {
		const int screenSize = screenSizeMetaEnum.value(idx);
		ThemeInfo themeInfo;
		themeInfo.variesByScreenSize = true;
		themeInfo.ternaryCondition = QStringLiteral("%1 == Theme::%2 ?").arg(
			generateFlatThemeObject ? QStringLiteral("m_screenSize") : QStringLiteral("m_themeValue"),
			QString(screenSizeMetaEnum.key(idx)));
		bool typographyDesign = parseTheme(QStringLiteral("%1/typography/TypographyDesign.json").arg(themeDir), &themeInfo, generateFlatThemeObject);
		bool typography = parseTheme(QStringLiteral("%1/typography/%2.json")
			.arg(themeDir, screenSizeMetaEnum.valueToKey(screenSize)), &themeInfo, generateFlatThemeObject);
		bool geometry = parseTheme(QStringLiteral("%1/geometry/%2.json")
			.arg(themeDir, screenSizeMetaEnum.valueToKey(screenSize)), &themeInfo, generateFlatThemeObject);
		m_sizeVaryingThemeValues.append(themeInfo);
		ret = ret && typographyDesign && typography && geometry;
	}

	auto colorSchemeMetaEnum = QMetaEnum::fromType<ThemeParser::ColorScheme>();
	for (int idx = 0; idx < colorSchemeMetaEnum.keyCount(); ++idx) {
		const int colorScheme = colorSchemeMetaEnum.value(idx);
		ThemeInfo themeInfo;
		themeInfo.variesByColorScheme = true;
		themeInfo.ternaryCondition = QStringLiteral("%1 == Theme::%2 ?").arg(
			generateFlatThemeObject ? QStringLiteral("m_colorScheme") : QStringLiteral("m_themeValue"),
			QString(colorSchemeMetaEnum.key(idx)));
		bool colorDesign = parseTheme(QStringLiteral("%1/color/ColorDesign.json").arg(themeDir), &themeInfo, generateFlatThemeObject);
		bool color = parseTheme(QStringLiteral("%1/color/%2.json")
			.arg(themeDir, colorSchemeMetaEnum.valueToKey(colorScheme)), &themeInfo, generateFlatThemeObject);
		m_colorVaryingThemeValues.append(themeInfo);
		ret = ret && colorDesign && color;
	}

	{
		ThemeInfo themeInfo;
		bool animation = parseTheme(QStringLiteral("%1/animation/Animation.json").arg(themeDir), &themeInfo, generateFlatThemeObject);
		m_nonVaryingThemeValues.append(themeInfo);
		ret = ret && animation;
	}

	return ret;
}

QVariant ThemeParser::resolvedValue(
		const QString &key,
		bool *found,
		bool warnOnFailure,
		ThemeInfo *themeInfo)
{
	if (found) *found = false;
	const QString resolvedSubTree = key.mid(0, key.lastIndexOf(QLatin1Char('.')));
	if (!themeInfo->subtrees.contains(resolvedSubTree)) {
		if (warnOnFailure) qWarning() << "Theme: unable to resolve:" << key << ": subtree does not exist.";
	} else {
		QVariantMap *subtree = themeInfo->subtrees[resolvedSubTree];
		const QString valueKey = key.mid(resolvedSubTree.length()+1);
		if (!subtree->contains(valueKey)) {
			if (warnOnFailure) qWarning() << "Theme: unable to resolve:" << key << ": subtree does not contain key.";
		} else {
			if (found) *found = true;
			return subtree->value(valueKey);
		}
	}
	return QVariant();
}

QColor ThemeParser::resolvedColor(const QString &value)
{
	static const QRegularExpression hexColor = ::optimizeExpression(
			QStringLiteral("^#[0-9a-fA-F]{6,8}$"));
	static const QRegularExpression rgbaColor = ::optimizeExpression(
			QStringLiteral("^rgba\\((\\d+), (\\d+), (\\d+), (\\d+(?:\\.\\d+)?)\\)$"));

	if (value == "transparent") {
		return QColor(value);
	}

	QRegularExpressionMatch match = hexColor.match(value);
	if (match.hasMatch()) {
		return QColor(value);
	}

	match = rgbaColor.match(value);
	if (match.hasMatch()) {
		return QColor(
			match.captured(1).toInt(),
			match.captured(2).toInt(),
			match.captured(3).toInt(),
			qRound(255 * match.captured(4).toDouble()));
	}

	return {};
}

QVariant ThemeParser::parseValue(
		const QJsonValue &value,
		const QString &key,
		bool defer,
		ThemeInfo *themeInfo)
{
	if (value.isString()) {
		const QString valueStr = value.toString();

		QColor color = resolvedColor(valueStr);
		if (color.isValid()) {
			return QVariant::fromValue<QColor>(color);
		}

		// Check to see if the value should resolve to a pre-existing theme value.
		if (!valueStr.contains('.')) {
			return valueStr; // no, just a string value.
		}

		bool found = false;
		const QVariant var = resolvedValue(valueStr, &found, !defer, themeInfo);
		if (found) {
			if (var.isNull()) {
				// Still not resolved - try again
				themeInfo->deferred.push_back({ key, value });
			}
			return var;
		} else if (defer) {
			themeInfo->deferred.push_back({ key, value });
			return QVariant();
		}

		return valueStr;
	} else {
		if (value.isBool()) {
			return value.toBool();
		} else if (value.isDouble()) {
			// JSON only supports double numbers, but we have a lot of int values.
			if (QString::number(value.toDouble()).contains('.')) {
				return value.toDouble();
			} else {
				return value.toInt();
			}
		} else {
			return value.toVariant();
		}
	}
}

void ThemeParser::insertValue(
		QVariantMap *tree,
		const QString &key,
		const QJsonValue &value,
		int depth,
		bool defer,
		ThemeInfo *themeInfo)
{
	const int dot = static_cast<int>(key.indexOf(QLatin1Char('.'), depth));
	if (dot == -1) {
		const QString name = key.mid(depth);
		tree->insert(name, parseValue(value, key, defer, themeInfo));
		return;
	}

	const QString subtreeKey = key.mid(0, dot);
	QVariantMap *subtree = nullptr;
	if (themeInfo->subtrees.contains(subtreeKey)) {
		subtree = themeInfo->subtrees[subtreeKey];
	} else {
		subtree = new QVariantMap;
		themeInfo->subtrees.insert(subtreeKey, subtree);
		tree->insert(key.mid(depth, dot-depth), QVariant::fromValue(subtree));
	}
	insertValue(subtree, key, value, dot+1, defer, themeInfo);
}

bool ThemeParser::parseTheme(const QString &themeFile, ThemeInfo *themeInfo, bool generateFlatThemeObject)
{
	QFile file(themeFile);
	if (!file.open(QIODevice::ReadOnly)) {
		qWarning() << "Error opening theme file:" << themeFile
			<< ":" << file.errorString();
		return false;
	}

	QJsonParseError err;
	const QJsonDocument doc = QJsonDocument::fromJson(file.readAll(), &err);
	if (doc.isNull()) {
		qWarning() << "Error parsing JSON:" << themeFile
			<< ":" << qPrintable(err.errorString());
		return false;
	}

	const QJsonObject obj = doc.object();
	for (auto it = obj.constBegin(); it != obj.constEnd(); ++it) {
		insertValue(&themeInfo->values, it.key(), it.value(), 0, true, themeInfo);
	}

	// Process any previously deferred values
	while (!themeInfo->deferred.empty()) {
		const auto &pair(themeInfo->deferred.front());
		insertValue(&themeInfo->values, pair.first, pair.second, 0, false, themeInfo);
		themeInfo->deferred.pop_front();
	}

	if (generateFlatThemeObject) {
		// construct a flat variant map from our nested tree of values.
		QVariantMap flat;
		for (const QString &prefix : themeInfo->subtrees.keys()) {
			QVariantMap *nested = themeInfo->subtrees.value(prefix);
			if (nested) {
				for (const QString &key : nested->keys()) {
					const QVariant value = nested->value(key);
					if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
						flat.insert(QStringLiteral("%1.%2").arg(prefix, key).replace('.', '_'), value);
					}
				}
			}
		}
		for (const QString &key : themeInfo->values.keys()) {
			const QVariant value = themeInfo->values.value(key);
			if (value.typeId() != qMetaTypeId<QVariantMap*>()) {
				flat.insert(key, value);
			}
		}
		themeInfo->values = flat;
	}

	return true;
}

} // VenusOS
} // Victron

